<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Czech Flashcard App - Multi-User</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/tesseract.js@4/dist/tesseract.min.js"></script>
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🇨🇿</text></svg>">
    <meta name="description" content="Learn Czech vocabulary with multi-user cloud-synced flashcards!">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#3B82F6">
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const { createClient } = supabase;

        // Supabase credentials
        const supabaseUrl = 'https://luydswutvsttbpvruylm.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx1eWRzd3V0dnN0dGJwdnJ1eWxtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg2MDQzMjgsImV4cCI6MjA2NDE4MDMyOH0.RvrljR2_T4oDCWkyrvCxPSRc7aiUYflzQ8sX_cU-urI';
        const supabaseClient = createClient(supabaseUrl, supabaseKey);

        const CzechFlashcardApp = () => {
            // All state variables
            const [currentScreen, setCurrentScreen] = useState('login');
            const [currentCardIndex, setCurrentCardIndex] = useState(0);
            const [showAnswer, setShowAnswer] = useState(false);
            const [studyCards, setStudyCards] = useState([]);
            const [correctCount, setCorrectCount] = useState(0);
            const [incorrectCount, setIncorrectCount] = useState(0);
            const [allVocabulary, setAllVocabulary] = useState([]);
            const [isProcessingImage, setIsProcessingImage] = useState(false);
            const [newCards, setNewCards] = useState([]);
            const [validationResults, setValidationResults] = useState([]);
            const [isValidating, setIsValidating] = useState(false);
            const [manualCzech, setManualCzech] = useState('');
            const [manualEnglish, setManualEnglish] = useState('');
            const [userId, setUserId] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [isSyncing, setIsSyncing] = useState(false);
            const [lastSyncTime, setLastSyncTime] = useState(null);
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [isRegistering, setIsRegistering] = useState(false);
            const [isLoggedIn, setIsLoggedIn] = useState(false);
            const [currentUser, setCurrentUser] = useState(null);
            const [connectionError, setConnectionError] = useState(null);
            const [csvFile, setCsvFile] = useState(null);
            const [csvCards, setCsvCards] = useState([]);
            const [csvValidationResults, setCsvValidationResults] = useState([]);
            const [isProcessingCsv, setIsProcessingCsv] = useState(false);
            const fileInputRef = useRef(null);
            const [showImageOptions, setShowImageOptions] = useState(false);
            const galleryInputRef = useRef(null);
            const cameraInputRef = useRef(null);

            // User management functions with Supabase
            const registerUser = async (email, password, username) => {
                try {
                    setIsLoading(true);
                    setConnectionError(null);
                    
                    // Register with Supabase Auth
                    const { data, error } = await supabaseClient.auth.signUp({
                        email: email,
                        password: password,
                        options: {
                            data: {
                                username: username
                            }
                        }
                    });

                    if (error) {
                        console.error('Registration error:', error);
                        setConnectionError(`Registration failed: ${error.message}`);
                        return false;
                    }

                    alert('Registration successful! Please check your email to verify your account, then sign in.');
                    return true;
                } catch (error) {
                    console.error('Registration error:', error);
                    setConnectionError('Registration failed. Please check your internet connection and try again.');
                    return false;
                } finally {
                    setIsLoading(false);
                }
            };

            const loginUser = async (email, password) => {
                try {
                    setIsLoading(true);
                    setConnectionError(null);
                    
                    const { data, error } = await supabaseClient.auth.signInWithPassword({
                        email: email,
                        password: password
                    });

                    if (error) {
                        console.error('Login error:', error);
                        setConnectionError(`Login failed: ${error.message}`);
                        return false;
                    }

                    return data.user;
                } catch (error) {
                    console.error('Login error:', error);
                    setConnectionError('Login failed. Please check your internet connection and try again.');
                    return false;
                } finally {
                    setIsLoading(false);
                }
            };

            const logoutUser = async () => {
                try {
                    await supabaseClient.auth.signOut();
                    setIsLoggedIn(false);
                    setCurrentUser(null);
                    setUserId('');
                    setAllVocabulary([]);
                    setEmail('');
                    setPassword('');
                    setCurrentScreen('login');
                    setLastSyncTime(null);
                } catch (error) {
                    console.error('Logout error:', error);
                }
            };

            const loadUserVocabulary = async (user) => {
                try {
                    setIsLoading(true);
                    console.log('Loading vocabulary for user:', user.id);
                    
                    const { data, error } = await supabaseClient
                        .from('user_vocabulary')
                        .select('vocabulary, updated_at')
                        .eq('user_id', user.id)
                        .single();

                    if (error) {
                        console.error('Error loading vocabulary:', error);
                        
                        if (error.code === 'PGRST116') { 
                            // No rows found - create initial record
                            console.log('No vocabulary found, creating initial record');
                            await saveToDatabase([]);
                            setAllVocabulary([]);
                        } else if (error.code === '42501') {
                            // Permission denied - RLS issue
                            alert('Permission denied. Please check your account access.');
                            setAllVocabulary([]);
                        } else {
                            // Other errors
                            console.error('Database error:', error.message);
                            setAllVocabulary([]);
                        }
                        return;
                    }

                    if (data && data.vocabulary) {
                        console.log('Loaded vocabulary:', data.vocabulary.length, 'cards');
                        setAllVocabulary(data.vocabulary || []);
                        setLastSyncTime(new Date(data.updated_at));
                    } else {
                        setAllVocabulary([]);
                    }
                } catch (error) {
                    console.error('Error loading vocabulary:', error);
                    setAllVocabulary([]);
                } finally {
                    setIsLoading(false);
                }
            };

            const saveToDatabase = async (vocabulary) => {
                if (!currentUser || isSyncing) return;
                
                try {
                    setIsSyncing(true);
                    console.log('Saving vocabulary for user:', currentUser.id, 'Cards:', vocabulary.length);
                    
                    const { data, error } = await supabaseClient
                        .from('user_vocabulary')
                        .upsert({
                            user_id: currentUser.id,
                            vocabulary: vocabulary,
                            updated_at: new Date().toISOString()
                        }, {
                            onConflict: 'user_id'
                        });

                    if (error) {
                        console.error('Error saving vocabulary:', error);
                        
                        if (error.code === '42501') {
                            alert('Permission denied. Please check your account permissions.');
                        } else if (error.code === '23505') {
                            // Unique constraint violation - try update instead
                            console.log('Trying update instead of upsert...');
                            const { error: updateError } = await supabaseClient
                                .from('user_vocabulary')
                                .update({
                                    vocabulary: vocabulary,
                                    updated_at: new Date().toISOString()
                                })
                                .eq('user_id', currentUser.id);
                                
                            if (updateError) {
                                console.error('Update also failed:', updateError);
                                alert('Failed to save vocabulary. Please try again.');
                            } else {
                                setLastSyncTime(new Date());
                                console.log('Successfully updated vocabulary');
                            }
                        } else {
                            alert(`Failed to sync vocabulary: ${error.message}`);
                        }
                    } else {
                        setLastSyncTime(new Date());
                        console.log('Successfully synced vocabulary');
                    }
                } catch (error) {
                    console.error('Error saving vocabulary:', error);
                    alert('Sync failed due to network error. Please check your connection.');
                } finally {
                    // Add a small delay before allowing next sync
                    setTimeout(() => {
                        setIsSyncing(false);
                    }, 1000);
                }
            };

            const handleLogin = async (e) => {
                e.preventDefault();
                if (!email.trim() || !password.trim()) {
                    setConnectionError('Please enter both email and password');
                    return;
                }

                // Basic email validation
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                if (!emailRegex.test(email.trim())) {
                    setConnectionError('Please enter a valid email address');
                    return;
                }

                if (isRegistering) {
                    // For registration, use email prefix as username if no separate username provided
                    const usernameForRegistration = email.split('@')[0]; // Use email prefix as username
                    
                    const success = await registerUser(email.trim(), password, usernameForRegistration);
                    if (success) {
                        setIsRegistering(false);
                        setPassword('');
                    }
                } else {
                    const user = await loginUser(email.trim(), password);
                    if (user) {
                        setCurrentUser(user);
                        setUserId(user.id);
                        setIsLoggedIn(true);
                        setCurrentScreen('home');
                        await loadUserVocabulary(user);
                    }
                }
            };

            const handleLogout = () => {
                logoutUser();
            };

            // Study functions
            const shuffleCards = () => {
                const shuffled = [...allVocabulary].sort(() => Math.random() - 0.5);
                setStudyCards(shuffled);
            };

            const startStudySession = () => {
                shuffleCards();
                setCurrentCardIndex(0);
                setShowAnswer(false);
                setCorrectCount(0);
                setIncorrectCount(0);
                setCurrentScreen('study');
            };

            const handleAnswer = (isCorrect) => {
                if (isCorrect) {
                    setCorrectCount(prev => prev + 1);
                } else {
                    setIncorrectCount(prev => prev + 1);
                }

                setTimeout(() => {
                    if (currentCardIndex < studyCards.length - 1) {
                        setCurrentCardIndex(prev => prev + 1);
                        setShowAnswer(false);
                    } else {
                        setCurrentScreen('results');
                    }
                }, 500);
            };

            const addManualCard = (czech, english) => {
                if (!czech.trim() || !english.trim()) {
                    alert('Please fill in both Czech and English fields');
                    return;
                }
                
                const newCard = { czech: czech.trim(), english: english.trim() };
                const updatedVocabulary = [...allVocabulary, newCard];
                setAllVocabulary(updatedVocabulary);
                setManualCzech('');
                setManualEnglish('');
                alert('Card added successfully!');
                
                // Manual sync after adding card
                setTimeout(() => {
                    saveToDatabase(updatedVocabulary);
                }, 500);
            };

            const handleManualSubmit = (e) => {
                e.preventDefault();
                addManualCard(manualCzech, manualEnglish);
            };

            // CSV processing functions
            const handleCsvUpload = async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                if (!file.name.toLowerCase().endsWith('.csv')) {
                    alert('Please upload a CSV file');
                    return;
                }

                setIsProcessingCsv(true);
                setCurrentScreen('csvProcessing');

                try {
                    const text = await file.text();
                    parseCsvText(text);
                } catch (error) {
                    console.error('Error reading CSV file:', error);
                    alert('Error reading CSV file. Please try again.');
                    setCurrentScreen('home');
                }

                setIsProcessingCsv(false);
            };

            const parseCsvText = (csvText) => {
                console.log('Parsing CSV text:', csvText);
                
                const lines = csvText.split('\n').filter(line => line.trim());
                const parsed = [];
                const validationRes = [];

                lines.forEach((line, index) => {
                    // Skip header row if it exists
                    if (index === 0 && (line.toLowerCase().includes('czech') || line.toLowerCase().includes('english'))) {
                        return;
                    }

                    // Try different CSV delimiters
                    let parts = [];
                    if (line.includes(',')) {
                        parts = line.split(',');
                    } else if (line.includes(';')) {
                        parts = line.split(';');
                    } else if (line.includes('\t')) {
                        parts = line.split('\t');
                    }

                    if (parts.length >= 2 && parsed.length < 300) {
                        let czech = parts[0].trim().replace(/^["'](.*)["']$/, '$1');
                        let english = parts[1].trim().replace(/^["'](.*)["']$/, '$1');

                        if (czech.length >= 2 && english.length >= 2) {
                            const validation = validateCardPair(czech, english);
                            parsed.push({ czech, english, id: index });
                            validationRes.push(validation);
                            console.log(`Found CSV pair: "${czech}" - "${english}"`);
                        }
                    }
                });

                console.log(`Parsed ${parsed.length} CSV pairs`);
                setCsvCards(parsed);
                setCsvValidationResults(validationRes);
                
                if (parsed.length === 0) {
                    alert(`No vocabulary pairs found in CSV. Make sure your CSV has this format:\n\nczech_word,english_word\ndobrý den,good day\nděkuji,thank you`);
                }
            };

            const addCsvCardsToVocabulary = () => {
                const validCards = csvCards.filter((card, index) => {
                    const validation = csvValidationResults[index];
                    return !validation || validation.isValid || card.manuallyApproved;
                });
                
                const updatedVocabulary = [...allVocabulary, ...validCards];
                setAllVocabulary(updatedVocabulary);
                setCsvCards([]);
                setCsvValidationResults([]);
                setCurrentScreen('home');
                alert(`Added ${validCards.length} new cards from CSV to your vocabulary!`);
                
                // Manual sync after adding cards from CSV
                setTimeout(() => {
                    saveToDatabase(updatedVocabulary);
                }, 500);
            };

            const approveCsvCard = (index) => {
                const updated = [...csvCards];
                updated[index].manuallyApproved = true;
                setCsvCards(updated);
            };

            const editCsvCard = (index, field, value) => {
                const updated = [...csvCards];
                updated[index][field] = value;
                setCsvCards(updated);
            };

            const removeCsvCard = (index) => {
                const updated = csvCards.filter((_, i) => i !== index);
                setCsvCards(updated);
            };

            const forceSync = async () => {
                if (!isSyncing) {
                    await saveToDatabase(allVocabulary);
                }
            };

            const validateCzechWord = (word) => {
                const cleanWord = word.toLowerCase().trim();
                const czechChars = ['č', 'š', 'ž', 'ř', 'ď', 'ť', 'ň', 'ů', 'á', 'é', 'í', 'ó', 'ú', 'ý'];
                const hasCzechChars = czechChars.some(char => cleanWord.includes(char));
                return hasCzechChars || cleanWord.length >= 3;
            };

            const validateEnglishWord = (word) => {
                const cleanWord = word.toLowerCase().trim();
                const englishPattern = /^[a-z\s\-'\.]+$/i;
                return englishPattern.test(cleanWord) && cleanWord.length >= 1;
            };

            const validateCardPair = (czech, english) => {
                const czechValid = validateCzechWord(czech);
                const englishValid = validateEnglishWord(english);
                
                return {
                    isValid: czechValid && englishValid,
                    czechValid,
                    englishValid,
                    issues: [
                        ...(!czechValid ? ['Czech word might be incorrect'] : []),
                        ...(!englishValid ? ['English word might be incorrect'] : [])
                    ]
                };
            };

            const parseExtractedText = (text) => {
                console.log('Parsing text:', text);
                
                const lines = text.split('\n').filter(line => line.trim());
                const parsed = [];
                const validationRes = [];

                lines.forEach((line, index) => {
                    // Clean up the line
                    const cleanLine = line.trim().replace(/[""]/g, '"').replace(/['']/g, "'");
                    
                    // Try multiple patterns for Czech-English pairs
                    const patterns = [
                        /^(.+?)\s*[-–—]\s*(.+)$/,           // dash variants
                        /^(.+?)\s*[:]\s*(.+)$/,             // colon
                        /^(.+?)\s*[→➜]\s*(.+)$/,           // arrows
                        /^(.+?)\s*[=]\s*(.+)$/,             // equals
                        /^(.+?)\s*[|]\s*(.+)$/,             // pipe
                        /^(.+?)\s+([A-Za-z].*)$/,           // space separated (if second part starts with letter)
                        /^(.+?)\s*[,]\s*(.+)$/,             // comma
                        /^(.+?)\s*[;]\s*(.+)$/,             // semicolon
                    ];
                    
                    let match = null;
                    for (const pattern of patterns) {
                        match = cleanLine.match(pattern);
                        if (match) break;
                    }
                    
                    if (match && parsed.length < 200) {
                        let czech = match[1].trim();
                        let english = match[2].trim();
                        
                        // Clean up common OCR artifacts
                        czech = czech.replace(/[|]/g, 'l').replace(/[0]/g, 'o').replace(/[5]/g, 's');
                        english = english.replace(/[|]/g, 'l').replace(/[0]/g, 'o').replace(/[5]/g, 's');
                        
                        // Remove quotes if they wrap the entire string
                        czech = czech.replace(/^["'](.*)["']$/, '$1');
                        english = english.replace(/^["'](.*)["']$/, '$1');
                        
                        // Skip if either part is too short or contains mostly numbers/symbols
                        if (czech.length >= 2 && english.length >= 2 && 
                            !/^\d+$/.test(czech) && !/^\d+$/.test(english) &&
                            !/^[^a-zA-ZáčďéěíňóřšťúůýžÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/.test(czech) &&
                            !/^[^a-zA-Z]+$/.test(english)) {
                            
                            const validation = validateCardPair(czech, english);
                            parsed.push({ czech, english, id: index });
                            validationRes.push(validation);
                            
                            console.log(`Found pair: "${czech}" - "${english}"`);
                        }
                    }
                });

                console.log(`Parsed ${parsed.length} pairs`);
                setNewCards(parsed);
                setValidationResults(validationRes);
                
                if (parsed.length > 0) {
                    setIsValidating(true);
                    setTimeout(() => {
                        setIsValidating(false);
                    }, 1500);
                } else {
                    // If no pairs found, show the raw text to user for manual input
                    alert(`No vocabulary pairs detected. Raw text extracted:\n\n${text}\n\nYou can add cards manually instead.`);
                }
            };

            const preprocessImage = (file) => {
                return new Promise((resolve) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    
                    img.onload = () => {
                        // Calculate optimal size (max 2000px width while maintaining aspect ratio)
                        const maxWidth = 2000;
                        const scale = Math.min(1, maxWidth / img.width);
                        const newWidth = img.width * scale;
                        const newHeight = img.height * scale;
                        
                        // Set canvas size to higher resolution
                        canvas.width = newWidth;
                        canvas.height = newHeight;
                        
                        // Enable image smoothing for better quality
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';
                        
                        // Draw image with high quality
                        ctx.drawImage(img, 0, 0, newWidth, newHeight);
                        
                        // Get image data for processing
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;
                        
                        // Enhanced image processing for better OCR
                        for (let i = 0; i < data.length; i += 4) {
                            const red = data[i];
                            const green = data[i + 1];
                            const blue = data[i + 2];
                            
                            // Calculate luminance
                            const luminance = 0.299 * red + 0.587 * green + 0.114 * blue;
                            
                            // Adaptive thresholding - more sophisticated than simple threshold
                            const threshold = 140; // Adjust based on image
                            const contrast = luminance > threshold ? 255 : 0;
                            
                            // Apply processed values
                            data[i] = contrast;     // red
                            data[i + 1] = contrast; // green  
                            data[i + 2] = contrast; // blue
                            // Alpha stays the same
                        }
                        
                        // Put processed image back
                        ctx.putImageData(imageData, 0, 0);
                        
                        // Convert to high quality blob
                        canvas.toBlob(resolve, 'image/png', 1.0);
                    };
                    
                    img.onerror = () => {
                        console.error('Failed to load image for preprocessing');
                        resolve(file); // Fallback to original file
                    };
                    
                    img.src = URL.createObjectURL(file);
                });
            };

            const handleImageUpload = async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                setIsProcessingImage(true);
                setCurrentScreen('imageProcessing');

                try {
                    console.log('Starting OCR process...');
                    
                    if (window.Tesseract) {
                        // Preprocess the image for better OCR
                        const processedImage = await preprocessImage(file);
                        
                        // Enhanced OCR configuration
                        const { data: { text } } = await window.Tesseract.recognize(processedImage, 'ces+eng', {
                            logger: m => {
                                console.log(m);
                                if (m.status === 'recognizing text') {
                                    // You could add a progress bar here
                                }
                            },
                            tessedit_pageseg_mode: '6', // Assume uniform block of text
                            tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzáčďéěíňóřšťúůýžÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ0123456789 -:→=.,!?()[]{}/"\'',
                            preserve_interword_spaces: '1',
                        });
                        
                        console.log('OCR Result:', text);
                        
                        if (text.trim()) {
                            parseExtractedText(text);
                        } else {
                            // Fallback: Ask user to manually enter text
                            const userText = prompt(`OCR couldn't extract clear text. Please manually enter the Czech-English pairs you see in the image (format: "czech - english", one per line):`);
                            if (userText) {
                                parseExtractedText(userText);
                            } else {
                                setCurrentScreen('home');
                            }
                        }
                    } else {
                        // Fallback: Ask user to manually enter text they see in the image
                        const userText = prompt(`OCR library not loaded. Please manually enter the Czech-English pairs you see in the image (format: "czech - english", one per line):`);
                        if (userText) {
                            parseExtractedText(userText);
                        } else {
                            setCurrentScreen('home');
                        }
                    }
                } catch (error) {
                    console.error('Error processing image:', error);
                    
                    // Fallback: Ask user to manually enter text
                    const userText = prompt(`Error processing image. Please manually enter the Czech-English pairs you see (format: "czech - english", one per line):`);
                    if (userText) {
                        parseExtractedText(userText);
                    } else {
                        alert('Error processing image. Please try again with a clearer image.');
                        setCurrentScreen('home');
                    }
                }
                
                setIsProcessingImage(false);
            };

            const addNewCardsToVocabulary = () => {
                const validCards = newCards.filter((card, index) => {
                    const validation = validationResults[index];
                    return !validation || validation.isValid || card.manuallyApproved;
                });
                
                const updatedVocabulary = [...allVocabulary, ...validCards];
                setAllVocabulary(updatedVocabulary);
                setNewCards([]);
                setValidationResults([]);
                setCurrentScreen('home');
                alert(`Added ${validCards.length} new cards to your vocabulary!`);
                
                // Manual sync after adding cards from image
                setTimeout(() => {
                    saveToDatabase(updatedVocabulary);
                }, 500);
            };

            const approveCard = (index) => {
                const updated = [...newCards];
                updated[index].manuallyApproved = true;
                setNewCards(updated);
            };

            const editCard = (index, field, value) => {
                const updated = [...newCards];
                updated[index][field] = value;
                setNewCards(updated);
            };

            const removeCard = (index) => {
                const updated = newCards.filter((_, i) => i !== index);
                setNewCards(updated);
            };

            // Initialize app and check for existing session
            useEffect(() => {
                const checkSession = async () => {
                    try {
                        console.log('Starting session check...');
                        setIsLoading(true);
                        
                        // Add timeout to prevent hanging
                        const sessionPromise = supabaseClient.auth.getSession();
                        const timeoutPromise = new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Session check timeout')), 10000)
                        );
                        
                        const { data: { session }, error } = await Promise.race([sessionPromise, timeoutPromise]);
                        
                        if (error) {
                            console.error('Session check error:', error);
                            setCurrentScreen('login');
                            return;
                        }
                        
                        if (session?.user) {
                            console.log('Found existing session for user:', session.user.email);
                            setCurrentUser(session.user);
                            setUserId(session.user.
